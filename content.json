{"meta":{"title":"禹哥小站","subtitle":"","description":"","author":"spartguo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Categories","date":"2019-11-07T08:52:01.000Z","updated":"2019-11-07T08:56:04.345Z","comments":false,"path":"Categories/index.html","permalink":"http://yoursite.com/Categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-07T07:33:35.000Z","updated":"2019-11-07T07:59:32.665Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis-发布者订阅者","slug":"Redis-发布者订阅者","date":"2019-11-16T10:21:54.000Z","updated":"2019-11-16T13:37:47.590Z","comments":true,"path":"2019/11/16/Redis-发布者订阅者/","link":"","permalink":"http://yoursite.com/2019/11/16/Redis-%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85/","excerpt":"","text":"引言本文参考了https://blog.csdn.net/clh604/article/details/19754939https://blog.csdn.net/gududedabai/article/details/80326129 简介 为了解耦发布者(publisher)和订阅者(subscriber)之间的关系，Redis 使用了 channel (频道)作为两者的中介 —— 发布者将信息直接发布给 channel ，而 channel 负责将信息发送给适当的订阅者，发布者和订阅者之间没有相互关系，也不知道对方的存在： 主要命令这里主要想写样例： PUBLISH 发布消息 样例实现（源码）PUBLISH的命令主要有这两个步骤 使用给定的频道作为键，在 redisServer.pubsub_channels 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。 遍历 redisServer.pubsub_patterns 链表，将链表中的模式和给定的频道进行匹配，如果匹配成功，那么将消息发布到相应模式的客户端当中。 PUBLISH 命令的实际实现由 pubsubPublishMessage 函数完成，它的完整定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 发送消息 int pubsubPublishMessage(robj *channel, robj *message) &#123; int receivers = 0; struct dictEntry *de; listNode *ln; listIter li; /* Send to clients listening for that channel */ // 向频道的所有订阅者发送消息 de = dictFind(server.pubsub_channels,channel); if (de) &#123; list *list = dictGetVal(de); // 取出所有订阅者 listNode *ln; listIter li; // 遍历所有订阅者， 向它们发送消息 listRewind(list,&amp;li); while ((ln = listNext(&amp;li)) != NULL) &#123; redisClient *c = ln-&gt;value; addReply(c,shared.mbulkhdr[3]); addReply(c,shared.messagebulk); addReplyBulk(c,channel); // 打印频道名 addReplyBulk(c,message); // 打印消息 receivers++; // 更新接收者数量 &#125; &#125; /* Send to clients listening to matching channels */ // 向所有被匹配模式的订阅者发送消息 if (listLength(server.pubsub_patterns)) &#123; listRewind(server.pubsub_patterns,&amp;li); // 取出所有模式 channel = getDecodedObject(channel); while ((ln = listNext(&amp;li)) != NULL) &#123; pubsubPattern *pat = ln-&gt;value; // 取出模式 // 如果模式和 channel 匹配的话 // 向这个channel的订阅者发送消息 if (stringmatchlen((char*)pat-&gt;pattern-&gt;ptr, sdslen(pat-&gt;pattern-&gt;ptr), (char*)channel-&gt;ptr, sdslen(channel-&gt;ptr),0)) &#123; addReply(pat-&gt;client,shared.mbulkhdr[4]); addReply(pat-&gt;client,shared.pmessagebulk); addReplyBulk(pat-&gt;client,pat-&gt;pattern); // 打印被匹配的模式 addReplyBulk(pat-&gt;client,channel); // 打印频道名 addReplyBulk(pat-&gt;client,message); // 打印消息 receivers++; // 更新接收者数量 &#125; &#125; decrRefCount(channel); // 释放用过的 channel &#125; return receivers; // 返回接收者数量 &#125; SUBSCRIBE 订阅频道 样例实现（源码）数据结构 123456struct redisServer &#123; // 省略 ... dict *pubsub_channels; // Map channels to list of subscribed clients // 省略 ... &#125;; pubsub_channels是个字典，字典的键就是一个个 channel ，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。(haspmap之类)，所以要订阅就现需要在里面加上自己 函数 pubsubSubscribeChannel 是 SUBSCRIBE 命令的底层实现，它完成了将客户端添加到订阅链表中的工作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 订阅指定频道 // 订阅成功返回 1 ，如果已经订阅过，返回 0 int pubsubSubscribeChannel(redisClient *c, robj *channel) &#123; struct dictEntry *de; list *clients = NULL; int retval = 0; /* Add the channel to the client -&gt; channels hash table */ /*dictadd函数其实就是在字典里面加键值对，channel作为键，null为值 这个函数会检查是否存在现有的channel，没有的话就创建一个，加到客户端的pubsub里面 */ //---------------关键-------------------- if (dictAdd(c-&gt;pubsub_channels,channel,NULL) == DICT_OK) &#123; retval = 1; //函数的作用是增加对对象的引用，我不知道要干啥,不过我知道引用为0会被删掉 incrRefCount(channel); /* Add the client to the channel -&gt; list of clients hash table */ // 将 client 添加到订阅给定 channel 的链表中 // 这个链表是一个哈希表的值，哈希表的键是给定 channel // 这个哈希表保存在 server.pubsub_channels 里 //-----------------关键------------------- de = dictFind(server.pubsub_channels,channel); if (de == NULL) &#123; // 如果 de 等于 NULL // 表示这个客户端是首个订阅这个 channel 的客户端 // 那么创建一个新的列表， 并将它加入到哈希表中 clients = listCreate(); dictAdd(server.pubsub_channels,channel,clients); incrRefCount(channel); &#125; else &#123; // 如果 de 不为空，就取出这个 clients 链表 clients = dictGetVal(de); &#125; // 将客户端加入到链表中 listAddNodeTail(clients,c); &#125; /* Notify the client */ addReply(c,shared.mbulkhdr[3]); addReply(c,shared.subscribebulk); // 返回订阅的频道 addReplyBulk(c,channel); // 返回客户端当前已订阅的频道和模式数量的总和 addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+listLength(c-&gt;pubsub_patterns)); return retval; &#125; dictAdd(...)源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*将给定键值对添加到字典中 * 只有给定键 key 不存在于字典时，添加操作才会成功 * 添加成功返回 DICT_OK , 失败返回 DICT_ERR */int dictAdd(dict *d, void *key, void *val)&#123; /* 新建节点,entry=null */ dictEntry *entry = dictAddRaw(d,key,NULL); /* 如果entry不为null，返回1 */ if (!entry) return DICT_ERR; /* 给节点赋值 */ dictSetVal(d, entry, val); /*先添加键再添加值*/ /* 操作成功，返回0 */ return DICT_OK;&#125;dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)&#123; long index; dictEntry *entry; dictht *ht; /* 指向字典中的hash表 */ /* 判断字典此时是否正在rehash */ if (dictIsRehashing(d)) _dictRehashStep(d); /* 如果新元素（key）已经存在，那么index=-1，否则index就是新元素的下标值 */ if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1) return NULL; /* 给新的entry分配内存空间并且保存新的entry， * 在这里，会将新的元素放在hash表的表头 */ /* 如果字典这是正在rehash，那么会将entry添加到ht[1]中去；否则添加到ht[0] */ ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0]; entry = zmalloc(sizeof(*entry)); entry-&gt;next = ht-&gt;table[index]; ht-&gt;table[index] = entry; ht-&gt;used++;/* 更新hash表中used属性的值 */ /* 设置entry的key */ dictSetKey(d, entry, key); return entry;&#125; PSUBSCRIBE 订阅模式（多个频道） 样例实现（源码）数据结构 和 redisServer.pubsub_channels 属性类似， redisServer.pubsub_patterns 属性用于保存所有被订阅的模式，和 pubsub_channels 不同的是， pubsub_patterns 是一个链表(而不是字典)： 123456struct redisServer &#123; // ...... list *pubsub_patterns; // A list of pubsub_patterns // ...... &#125; pubsubSubscribePattern 是 PSUBSCRIBE 的底层实现，它将客户端和所订阅的模式添加到redisServer.pubsub_patterns 当中： 123456789101112131415161718192021222324252627// 订阅指定模式 // 订阅成功返回 1 ，如果已经订阅过，返回 0 int pubsubSubscribePattern(redisClient *c, robj *pattern) &#123; int retval = 0; // 向 c-&gt;pubsub_patterns 中查找指定 pattern // 如果返回值为 NULL ，说明这个 pattern 还没被这个客户端订阅过 if (listSearchKey(c-&gt;pubsub_patterns,pattern) == NULL) &#123; retval = 1; // 添加 pattern 到客户端 pubsub_patterns listAddNodeTail(c-&gt;pubsub_patterns,pattern); incrRefCount(pattern); // 将 pattern 添加到服务器 pubsubPattern *pat; pat = zmalloc(sizeof(*pat)); pat-&gt;pattern = getDecodedObject(pattern); pat-&gt;client = c; listAddNodeTail(server.pubsub_patterns,pat); &#125; /* Notify the client */ addReply(c,shared.mbulkhdr[3]); addReply(c,shared.psubscribebulk); // 返回被订阅的模式 addReplyBulk(c,pattern); // 返回客户端当前已订阅的频道和模式数量的总和 addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+listLength(c-&gt;pubsub_patterns)); return retval; &#125; 这个的话如果每次添加都要去匹配每一个channel然后加client的话就太累了，这个东西也失去了意义，本来就是为了模式匹配的，这样一个个加，有点繁琐了。为了能让这玩意儿起作用，在publish中会在这里也遍历一次，在publish相应的执行函数中进行channel的对比，匹配上了就发。 UNSUBSCRIBE 不订阅 具体实现而对于 TIPS个人一些理解上卡的关键点： 1.在没有一个channel的情况下是通过怎样的方式创建channel的呢？ 这个要结合源代码来看，没有channel的时候，其实也就是这个channel被首次订阅的时候，这个时候会调用dictAdd，而且是加在服务端serer.pubsub上的，细节可以看上面的源码，。 2.如果自己没订阅的话别人订阅了，那在pubsub里面有其他人订阅了了岂不是自己就订阅不了了？ 这个是我自己眼角膜不要了，我没看清楚的是在订阅相关的函数中第一个if条件中的pubsub是c-&gt;pubsub_channels，也就是说是客户端的一个字典，客户端的字典只是存了自己订阅的，里面的值啥都没有的。而下面的de的判断是server.pubsub，也就是远程的，那里面的list就会保存所有订阅了相应channel的客户端了。 3.为什么有ht[0]，ht[1]，没有2和3或4吗？ 通过搜索资料发现，dicth哈希字典里面自带了两个哈希表，0和1，这个人家里面本来就有，没得杠。dictht0是直接存储哈希表的地方， dictht1在rehash中用到。里面的一些详细问题暂时还没有参透，日后再说。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"IOTA-介绍","slug":"IOTA-介绍","date":"2019-11-14T10:21:54.000Z","updated":"2019-11-16T08:36:50.076Z","comments":true,"path":"2019/11/14/IOTA-介绍/","link":"","permalink":"http://yoursite.com/2019/11/14/IOTA-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"引言本文参考了https://www.jianshu.com/p/45c72f6cb417https://www.iotachina.com/what-is-iota 简介 IOTA是为物联网（IoT）而设计的一个革命性的新型交易结算和数据转移层。它基于新型的分布式账本——Tangle（缠结）。Tangle能够克服现有区块链设计中的低效性，并为去中心化P2P系统共识的达成创造了一种新方法。通过IOTA进行转账不需要支付手续费，这是首例。这也就意味着，无论是多小额的支付都能通过IOTA完成。 IOTA的Tangle和区块链有什么不同？最小单位 区块链的最小单位是区块（可能包含多个交易） IOTA的最小单位是一次交易 架构他们是两个完全独立的架构，但是却建立在同一种规则之上。 IOTA共识机制创新 区块链共识是通过一个非常严格的机制完成的，区块链中添加下一个区块需要多方进行竞争，并获取区块奖励或交易手续费。正因如此，共识和交易生成是分离开的，并且由网络的一小部分人来完成，通常会设置较高门槛（就像比特币一样），这样会导致进一步的中心化。 在IOTA系统中，网络中的每位参与者都能进行交易并且积极参与共识。更具体点说，你直接定位了两笔交易（主交易和分支交易），且间接在子tangle中定位其它交易。通过这种方式，验证就能同步进行，网络能够保持完全去中心化，不需要矿工传递信任，也不需要支付交易手续费。 https://www.jianshu.com/p/ced888ba7d3a确认和共识讲解 手续费 基于比特币的交易需要支付矿工手续费，这里的矿工就是建立区块的节点。在未来小微支付广泛存在的物联网场景中，这种交易方式并不适用，因为这个手续费会大概率超过微小交易本身的价值，这种情况是非常不合理的。 同时，由于矿工的存在，使得比特币系统不可避免地拥有了节点二元性的特点 节点二元性：一类节点是参与交易的，而一类节点是参与确认交易的。这种二元性将会造成资源分配问题和公平性问题。 解决 ： 在IOTA中，每一笔新交易发生之前，该笔交易的节点首先要选择之前两个旧交易进行验证。验证通过后，该交易和被验证的两笔交易绑定。也就是说，要在IOTA网络上发行交易，就要对之前的交易进行验证。参与交易的每个节点都要承担一些矿工的义务，对整个网络的交易真实性负责。 这种记账的方式，不需要矿工，也不需要大量节点验证，这就节省了手续费和算力资源。有效地消除了手续费和网络二元性的问题，更加适用于大量节点之间小额交易的物联网场景。 交易过程选择旧交易一个节点在发行一个新的交易之前，首先要选择已经发生过的两个交易进行验证。关于选择哪两个交易，是IOTA技术的关键，最简单的策略是随机选择，并且要在还未被验证过的交易中进行选择。 （关键技术，还要深入） 验证旧交易选择好旧交易后，节点会对它们进行验证。要检查交易的签名是否正确，生成该交易的工作量大小，以及是否和与之直接或间接相连的交易有冲突。如果有冲突，则重新选择旧交易；如果没有冲突，则验证通过。 绑定旧交易验证通过后，节点将新生成的交易与已被验证的交易进行绑定。绑定过程需要做一点PoW计算，类似于比特币中的矿工，需要找到一个随机数满足如下条件：该随机数和被验证交易中的某个数值连接成新的字符串，该字符串对应的哈希值应满足某个固定格式。 （待补充，然后呢，需要广播吗》） （待补充）每次交易干了啥数据结构 IOTA的和其他代币最根本的区别是底层数据结构的不同。其他代币大多是用区块链存储交易数据，而IOTA则是采用了缠结Tangle作为其底层的数据结构。 Tangle Tangle是一种存储交易数据的有向无环图（Directed Acyclic Graph, DAG），其基本结构如图1所示。 （待加图） 风险交易冲突 IOTA通过交易权重解决这个问题。 每个交易在生成时，都会附带两个权重值。 自有权重，为3的指数，固定不变； 累计权重，是其后续绑定交易自有权重的累加，随着交易的增多而变大。 （待补充）权重怎么算，权重怎么起作用 pow共识机制 交易在被验证的时候，两个权重值是重要参考指标。累计权重越大的交易，意味着其可信度越高。在交易冲突发生的时候，会比较两个交易的累计权重，并舍弃那个累计权重较小的交易及其分支，后续如果遇到合适的时机会会再加上。","categories":[{"name":"IOTA","slug":"IOTA","permalink":"http://yoursite.com/categories/IOTA/"}],"tags":[{"name":"IOTA","slug":"IOTA","permalink":"http://yoursite.com/tags/IOTA/"},{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"论文","slug":"论文","permalink":"http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Redis-常用命令","slug":"Redis-常用命令","date":"2019-11-14T10:21:54.000Z","updated":"2019-11-16T08:24:53.428Z","comments":true,"path":"2019/11/14/Redis-常用命令/","link":"","permalink":"http://yoursite.com/2019/11/14/Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"引言参考 https://blog.csdn.net/weixx3/article/details/92188775暂未附上声明 #","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"java-拆箱装箱","slug":"java-拆箱装箱","date":"2019-11-09T10:21:54.000Z","updated":"2019-11-09T10:49:42.501Z","comments":true,"path":"2019/11/09/java-拆箱装箱/","link":"","permalink":"http://yoursite.com/2019/11/09/java-%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1/","excerpt":"","text":"前言本文转载于http://www.cnblogs.com/dolphin0520/p/3780005.html并根据自己的理解方式做了表达上的修改 概念Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行： 1Integer i = new Integer(10); 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了： 1Integer i = 10; 这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。 而拆箱就是将包装器类型的转化为基本数据类型的一个过程 12Integer i = 10; //装箱int n = i; //拆箱 实现原理Integer为例： 66通过javap -c 对.java文件进行反编译得到.class文件得到如下结果 在装箱的时候自动调用的是Integer的valueOf(int)方法 在拆箱的时候自动调用的是Integer的intValue方法 其他的数据类型也都是按照相似的方式拆箱装箱的 源码解析","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"http://yoursite.com/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"数据类型","slug":"数据类型","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"leetcode-最大回文子串","slug":"leetcode-最大回文子串","date":"2019-11-09T08:07:50.000Z","updated":"2019-11-09T08:58:45.629Z","comments":true,"path":"2019/11/09/leetcode-最大回文子串/","link":"","permalink":"http://yoursite.com/2019/11/09/leetcode-%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"暴力法不多做详解 1.中心扩展法此方法主要思想:通过查找以字符串中以某个字符为中心的回文子串是有多长，来得到每个回文子串的大小。对于这个子串，我们就从中心出发，向两边扩展，如果扩展后还是回文串，那么继续扩展，直到不是回文串，我们就可以将子串长度记录下来了。对于向两边扩展，我们可以通过一个下标来表示（也可以用指针），p1和p2。 现在有个问题，aabbaa和aabaa都是回文串，所以在打代码的时候就要稍稍做个处理。 两种情况 回文子串是奇数个，那么中心点就是一个字符，所以初始状态，p1和p2是指向同一个字符的。 回文子串是偶数个，那么中心就是两个字符，所以初始状态，p1和p2是指向两个相同字符的。 对于两种情况的处理打代码稍稍注意下就好了，问题不大。（这个方法暂无代码……） 2.动态规划主要思想：对于i到j是否是回文子串，我们只需要判断两个问题： i位置和j位置两个字符是否相同 如果相同了就判断i+1和j-1是否是个回文窜 有了这两点就没啥问题了 公式如下： 1dp[i][j] = dp[i+1][j-1] 这里的dp[i][j]存放的是boolean类型的，下面的dp存的是回文串长度 因为i一定会比j小，所以在二维数组上的操作要多多注意 一段比较原始的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String longestPalindrome(String s) &#123; if (s.length() &lt;=1)&#123; return s; &#125; int len = s.length(); int dp[][] = new int[len][len]; //初始化dp数组，主要是a和aa这种先准备好 //dp数组每个格子存放当前i到j的回文子串长度 for (int i = 0;i &lt; len;i++)&#123; dp[i][i] = 1; //i到i（单个字符）就是个回文串 if (i != len-1)&#123; //aa也是个回文串 if (s.charAt(i) == s.charAt(i+1))&#123; dp[i][i+1] = 2; &#125; &#125; &#125; //这个循环和是纵列在外，横行在内 for (int i = 2; i &lt; len; i ++)&#123; //这里是j到i for (int j = 0;j &lt; i-1;j++)&#123; if (s.charAt(j) == s.charAt(i))&#123; if (dp[j+1][i-1] == 0)&#123; dp[j][i] = dp[j+1][i-1]; &#125;else &#123; dp[j][i] = dp[j+1][i-1] +2 ; &#125; &#125; &#125; &#125; //把最大子串给截出来 int left = 0; int right = 0; int maxlen = 0; for (int i =0;i&lt; len;i++)&#123; for (int j = i;j &lt; len;j++)&#123; if (dp[i][j] &gt; maxlen)&#123; maxlen = dp[i][j]; left = i; right = j; &#125; &#125; &#125; return s.substring(left,right+1); &#125; 3.Manacher算法（待更）","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Linux下权限的修改设置","slug":"linux-permission","date":"2019-11-08T08:46:26.000Z","updated":"2019-11-09T07:03:19.907Z","comments":true,"path":"2019/11/08/linux-permission/","link":"","permalink":"http://yoursite.com/2019/11/08/linux-permission/","excerpt":"","text":"修改文件权限1$ chmod -R 777 files 1.先来讲讲数字777代表的是三个级别的身份owner/group/others 对于每个级别都有三个不同的权限 r 读权限read 4，100 w 写权限write 2，010 x 操作权限execute 1， 001 如果rwx都可以，就对三个数进行相加，等于7。这个就相当于3bit的位来表示单个级别身份的权限，某个位上的1表示有这个位代表的权限，0表示没有 2.接着讲讲 R对于R的话其实表示：对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) 3.其他当然除了 1chmod -R XXX file.txt 也有其他的方式，主要是依据owner/group/others三个用户来的。 栗子：设置文件拥有者权限为可写，组合为可读，其他用户删去可执行权限 1chmod u+w,g+r,o-x files.txt own对应 u group对应 g other对应 o 所有对应 a 此处自己只是列举了自己常用的，部分深入的细节没有完全解释清楚，网上也有大片的参考。 详细的可以百度chmod","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"初来乍到","slug":"myblog-creation","date":"2019-11-08T05:54:13.000Z","updated":"2019-11-09T09:02:50.526Z","comments":false,"path":"2019/11/08/myblog-creation/","link":"","permalink":"http://yoursite.com/2019/11/08/myblog-creation/","excerpt":"","text":"第一次建站，若有问题欢迎大家指正。","categories":[{"name":"Helloworld","slug":"Helloworld","permalink":"http://yoursite.com/categories/Helloworld/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/tags/HEXO/"}]}]}