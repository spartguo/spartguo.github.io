{"meta":{"title":"禹哥小站","subtitle":"","description":"","author":"spartguo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Categories","date":"2019-11-07T08:52:01.000Z","updated":"2019-11-07T08:56:04.345Z","comments":false,"path":"Categories/index.html","permalink":"http://yoursite.com/Categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-07T07:33:35.000Z","updated":"2019-11-07T07:59:32.665Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【转载】Redis-JeisPool.returnResource()被弃用","slug":"Redis-JedisPool.returnResource()","date":"2019-11-17T10:21:54.000Z","updated":"2019-11-17T13:00:46.822Z","comments":true,"path":"2019/11/17/Redis-JedisPool.returnResource()/","link":"","permalink":"http://yoursite.com/2019/11/17/Redis-JedisPool.returnResource()/","excerpt":"","text":"拷别人代码来跑的时候发现这个函数不能用，发现自己依赖导的是3.1，而人家的依赖导的版本是2.1，看了这篇文章才知道版本不支持了。 原文链接https://my.oschina.net/xiehongfei/blog/646125 自Jedis3.0版本后jedisPool.returnResource()遭弃用,官方重写了Jedis的close方法用以代替； 代码如下： 1234567891011121314151617/** * @deprecated starting from Jedis 3.0 this method will not be exposed. * Resource cleanup should be done using @see &#123;@link redis.clients.jedis.Jedis#close()&#125; */ @Override @Deprecated public void returnResource(final Jedis resource) &#123; if (resource != null) &#123; try &#123; resource.resetState(); returnResourceObject(resource); &#125; catch (Exception e) &#123; returnBrokenResource(resource); throw new JedisException(\"Could not return the resource to the pool\", e); &#125; &#125; &#125; 官方建议应用redis.clients.jedis#Jedis的close方法进行资源回收，官方代码如下： 123456789101112@Overridepublic void close() &#123; if (dataSource != null) &#123; if (client.isBroken()) &#123; this.dataSource.returnBrokenResource(this); &#125; else &#123; this.dataSource.returnResource(this); &#125; &#125; else &#123; client.close(); &#125;&#125;","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Spring-spring的bean","slug":"Spring-Bean","date":"2019-11-17T10:21:54.000Z","updated":"2019-11-17T12:55:11.279Z","comments":true,"path":"2019/11/17/Spring-Bean/","link":"","permalink":"http://yoursite.com/2019/11/17/Spring-Bean/","excerpt":"","text":"引言本文参考了https://www.awaimai.com/2596.htmljava bean是个什么概念什么是bean 因为最近在做东西的时候做着做着多想了一步，一问自己bean这样配了之后有啥用，一时间还真就没法解释清楚，不禁陷入哲学般的沉思，不知道怎么解释，说到底还是基础知识不牢固，在这里再整理一遍。 什么是Bean官方文档的解释： In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. 人话翻译： 在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化、组装和管理的对象。 提取关键信息可以得出 bean是对象，一个或者多个不限定 bean由Spring中一个叫IoC的东西管理 我们的应用程序由一个个bean构成 bean的规范 所有属性为private 提供默认构造方法 提供getter和setter 实现serializable接口 配置引起我思考的一个问题就是 我们在xml中配置了这么个东西，到底是干什么的。 1&lt;bean id=\"bean1\" class=\"demo2.bean1\"/&gt; 一开始反应是将这个类的对象实例化过程交给Spring IOC来管理。 这话不假，但是我一般会怎么用呢？里面的配置干啥的呢？ 对之前做的笔记进行整理发现，其实也很简单。 我们从头到尾整理一遍： 为什么要有这个配置首先我们有这么两个类 1234567891011121314public class Computer &#123; private String cpu; // CPU型号 private int ram; // RAM大小，单位GB public Computer(String cpu, int ram) &#123; this.cpu = cpu; this.ram = ram; &#125;&#125;public class Person &#123; private Computer computer; ......&#125; 很明显，Perso类需要用到Computer类，在这里我们发现，我们并没有直接new一个computer对象出来。在这里我们要先解释一下为什么要用IOC，而不是直接new。这玩意儿在大部分情况下都可以减少我们很多代码量。 为什么要用IOC有一个宽泛的说法是解耦，这里放一张图，大概是这么个意思，具体的场景也没遇到过，牛逼喊出来就好了。 没有解耦 没有解耦 解耦 解耦了 A需要用到B，C,D,E等等类的时候，我们需要一个个去new吗，不，太累了，用IOC吧，人家帮我搞的好好的，我只需要负责用就好了，因为一个new如果是简单的new还好，如果new的时候还要初始化很多东西，然后还不止一个要new，这个时候IOC的好处就体现出来了。 怎么用（配置）我们一般有三种方式来配置这个东西： 1.XML方式显示配置我们在配置好这个东西之后 12&lt;bean id=\"bean1\" class=\"demo2.bean1\"/&gt;&lt;!--如果需要的话还可以在里面加一些其他默认配置，比如名字默认是无名氏啥的--&gt; 这样一配，人家spring就可以通过你这个找到你这个类然后帮你自动new了。 自动new的话怎么样拿到人家的new的对象呢。 1234//通过工厂类拿到相应配置中的beanApplicationContext apc = new ClassPathXmlApplicationContext(\"configofdemo.xml\");userservice us=(userservice)apc.getBean(\"user\"); //获得 当然大部分情况下不会这样用，就和上面提到的，如果A需要newB,C,D,E,F。而且每一个都需要部分初始化配置，这个时候就可以这么来。 12345678910111213141516171819&lt;bean id=\"B\" class=\"xml.B\"&gt; &lt;!--初始化对象--&gt; &lt;property name=\"p1\" value=\"Hello\"/&gt; &lt;property name=\"p2\" value=\"Xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"C\" class=\"xml.C\"&gt; &lt;property name=\"p1\" value=\"Hello\"/&gt; &lt;property name=\"p2\" value=\"Xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"D\" class=\"xml.D\"&gt; &lt;property name=\"p1\" value=\"Hello\"/&gt; &lt;property name=\"p2\" value=\"Xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"A\" class=\"xml.A\"&gt; &lt;!--其实这个也是初始化--&gt; &lt;property name=\"依赖A\" ref=\"A\"/&gt; &lt;property name=\"依赖B\" ref=\"B\"/&gt; &lt;property name=\"依赖C\" ref=\"C\"/&gt;&lt;/bean&gt; 这里面的property也有其他的变化的，也有什么构造器啊啥的，具体的不细说，之前笔记有记一点，先放上来。 ref= 用于对象属性的时候用 property 用于有set和get方法的时候调用 construction用于构造函数 p名称空间属性注入复杂的： 数组、list—–property内用list —简单类型用value，复杂用ref； set——property内用set， map——property内用map——然后用entry 属性设置key 和value； properties——property里面用props———prop key=？ 标签间写内容 类似的有一个通过代码装配bean的，这个我不太熟，先把标题放着，后续更新 2.Java代码配置bean待更新………… 3.自动化装配这个和xml比的话，xml如果是你做了一道菜（创建一个类），然后写一个制作方法（xml配置bean），给springIOC容器让他帮你new的话。自动化装配就是自动记录你做菜的过程（创建类的时候就帮你搞定），其他啥都不用管。 写个比喻好累，不比喻了。其实这个就是注解。在类前面打上一个@component注解你就相当于写了个&lt;bean id=&quot;B&quot; class=&quot;xml.B&quot;&gt; 123456@Component(\"beanid\") //没有名字默认按类名作为idpublic class Aimpl implements A &#123; private B b; ...&#125; 一个类自己bean有了，但是这个类依赖了其他类的时候我们也需要设置的，本来在xml里面我们配置一个 1&lt;property name=\"依赖C\" ref=\"C\"/&gt; 但是现在我们只需要一个@Autowerid就好了，上面代码就变成了 123456@Component(\"bean_id\") //没有名字默认按类名作为idpublic class Aimpl implements A &#123; @Autowerid private B b; ...&#125; 对于类注解的话常用的有,大家都是bean，只不过名字不同罢了 repository———Dao类注解 service——-service类注解 controller——–controller注解 component——-普通 对于属性的注解 普通属性———value 类———autowerid（自动默认按类型注入autowerid下的qualifier后带名称精确定位（注解id——等于resource 最后在xml里面开启注解扫描。这个扫描的话呢就是相当于自动扫描你包下的所有类，只要是在类名和属性名前面打了相关的注解的话就把它自动作为bean导入到这里面，而不用手动去写。 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--后面的basepackage是我们要扫描的包--&gt; &lt;context:component-scan base-package=\"com.stalkers.impl\"/&gt;&lt;/bean&gt; 本文： 关于注解方面还不够详细，具体后续会加一篇。 java代码配置bean未总结 部分地方未完善 有问题欢迎指正","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Redis-发布者订阅者","slug":"Redis-发布者订阅者","date":"2019-11-16T10:21:54.000Z","updated":"2019-11-17T06:29:59.182Z","comments":true,"path":"2019/11/16/Redis-发布者订阅者/","link":"","permalink":"http://yoursite.com/2019/11/16/Redis-%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85/","excerpt":"","text":"引言本文参考了https://blog.csdn.net/clh604/article/details/19754939https://blog.csdn.net/gududedabai/article/details/80326129 简介 为了解耦发布者(publisher)和订阅者(subscriber)之间的关系，Redis 使用了 channel (频道)作为两者的中介 —— 发布者将信息直接发布给 channel ，而 channel 负责将信息发送给适当的订阅者，发布者和订阅者之间没有相互关系，也不知道对方的存在： 实现介绍订阅者订阅频道 订阅 发布者在相应频道发信息就好，完全不需要管谁订阅了，自动会发送到每个订阅者手中 发布 主要命令样例开启一个客户端先进行订阅。然后在另一个客户端在相应频道发布消息，两个客户端内容如下图。 订阅 发布消息 PUBLISH 发布消息 实现（源码）PUBLISH的命令主要有这两个步骤 使用给定的频道作为键，在 redisServer.pubsub_channels 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。 遍历 redisServer.pubsub_patterns 链表，将链表中的模式和给定的频道进行匹配，如果匹配成功，那么将消息发布到相应模式的客户端当中。 PUBLISH 命令的实际实现由 pubsubPublishMessage 函数完成，它的完整定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 发送消息 int pubsubPublishMessage(robj *channel, robj *message) &#123; int receivers = 0; struct dictEntry *de; listNode *ln; listIter li; /* Send to clients listening for that channel */ // 向频道的所有订阅者发送消息 de = dictFind(server.pubsub_channels,channel); if (de) &#123; list *list = dictGetVal(de); // 取出所有订阅者 listNode *ln; listIter li; // 遍历所有订阅者， 向它们发送消息 listRewind(list,&amp;li); while ((ln = listNext(&amp;li)) != NULL) &#123; redisClient *c = ln-&gt;value; addReply(c,shared.mbulkhdr[3]); addReply(c,shared.messagebulk); addReplyBulk(c,channel); // 打印频道名 addReplyBulk(c,message); // 打印消息 receivers++; // 更新接收者数量 &#125; &#125; /* Send to clients listening to matching channels */ // 向所有被匹配模式的订阅者发送消息 if (listLength(server.pubsub_patterns)) &#123; listRewind(server.pubsub_patterns,&amp;li); // 取出所有模式 channel = getDecodedObject(channel); while ((ln = listNext(&amp;li)) != NULL) &#123; pubsubPattern *pat = ln-&gt;value; // 取出模式 // 如果模式和 channel 匹配的话 // 向这个channel的订阅者发送消息 if (stringmatchlen((char*)pat-&gt;pattern-&gt;ptr, sdslen(pat-&gt;pattern-&gt;ptr), (char*)channel-&gt;ptr, sdslen(channel-&gt;ptr),0)) &#123; addReply(pat-&gt;client,shared.mbulkhdr[4]); addReply(pat-&gt;client,shared.pmessagebulk); addReplyBulk(pat-&gt;client,pat-&gt;pattern); // 打印被匹配的模式 addReplyBulk(pat-&gt;client,channel); // 打印频道名 addReplyBulk(pat-&gt;client,message); // 打印消息 receivers++; // 更新接收者数量 &#125; &#125; decrRefCount(channel); // 释放用过的 channel &#125; return receivers; // 返回接收者数量 &#125; SUBSCRIBE 订阅频道 实现（源码）数据结构 123456struct redisServer &#123; // 省略 ... dict *pubsub_channels; // Map channels to list of subscribed clients // 省略 ... &#125;; pubsub_channels是个字典，字典的键就是一个个 channel ，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。(haspmap之类)，所以要订阅就现需要在里面加上自己 函数 pubsubSubscribeChannel 是 SUBSCRIBE 命令的底层实现，它完成了将客户端添加到订阅链表中的工作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 订阅指定频道 // 订阅成功返回 1 ，如果已经订阅过，返回 0 int pubsubSubscribeChannel(redisClient *c, robj *channel) &#123; struct dictEntry *de; list *clients = NULL; int retval = 0; /* Add the channel to the client -&gt; channels hash table */ /*dictadd函数其实就是在字典里面加键值对，channel作为键，null为值 这个函数会检查是否存在现有的channel，没有的话就创建一个，加到客户端的pubsub里面 */ //---------------关键-------------------- if (dictAdd(c-&gt;pubsub_channels,channel,NULL) == DICT_OK) &#123; retval = 1; //函数的作用是增加对对象的引用，我不知道要干啥,不过我知道引用为0会被删掉 incrRefCount(channel); /* Add the client to the channel -&gt; list of clients hash table */ // 将 client 添加到订阅给定 channel 的链表中 // 这个链表是一个哈希表的值，哈希表的键是给定 channel // 这个哈希表保存在 server.pubsub_channels 里 //-----------------关键------------------- de = dictFind(server.pubsub_channels,channel); if (de == NULL) &#123; // 如果 de 等于 NULL // 表示这个客户端是首个订阅这个 channel 的客户端 // 那么创建一个新的列表， 并将它加入到哈希表中 clients = listCreate(); dictAdd(server.pubsub_channels,channel,clients); incrRefCount(channel); &#125; else &#123; // 如果 de 不为空，就取出这个 clients 链表 clients = dictGetVal(de); &#125; // 将客户端加入到链表中 listAddNodeTail(clients,c); &#125; /* Notify the client */ addReply(c,shared.mbulkhdr[3]); addReply(c,shared.subscribebulk); // 返回订阅的频道 addReplyBulk(c,channel); // 返回客户端当前已订阅的频道和模式数量的总和 addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+listLength(c-&gt;pubsub_patterns)); return retval; &#125; dictAdd(...)源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*将给定键值对添加到字典中 * 只有给定键 key 不存在于字典时，添加操作才会成功 * 添加成功返回 DICT_OK , 失败返回 DICT_ERR */int dictAdd(dict *d, void *key, void *val)&#123; /* 新建节点,entry=null */ dictEntry *entry = dictAddRaw(d,key,NULL); /* 如果entry不为null，返回1 */ if (!entry) return DICT_ERR; /* 给节点赋值 */ dictSetVal(d, entry, val); /*先添加键再添加值*/ /* 操作成功，返回0 */ return DICT_OK;&#125;dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)&#123; long index; dictEntry *entry; dictht *ht; /* 指向字典中的hash表 */ /* 判断字典此时是否正在rehash */ if (dictIsRehashing(d)) _dictRehashStep(d); /* 如果新元素（key）已经存在，那么index=-1，否则index就是新元素的下标值 */ if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1) return NULL; /* 给新的entry分配内存空间并且保存新的entry， * 在这里，会将新的元素放在hash表的表头 */ /* 如果字典这是正在rehash，那么会将entry添加到ht[1]中去；否则添加到ht[0] */ ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0]; entry = zmalloc(sizeof(*entry)); entry-&gt;next = ht-&gt;table[index]; ht-&gt;table[index] = entry; ht-&gt;used++;/* 更新hash表中used属性的值 */ /* 设置entry的key */ dictSetKey(d, entry, key); return entry;&#125; PSUBSCRIBE 订阅模式（多个频道） 实现（源码）数据结构 和 redisServer.pubsub_channels 属性类似， redisServer.pubsub_patterns 属性用于保存所有被订阅的模式，和 pubsub_channels 不同的是， pubsub_patterns 是一个链表(而不是字典)： 123456struct redisServer &#123; // ...... list *pubsub_patterns; // A list of pubsub_patterns // ...... &#125; pubsubSubscribePattern 是 PSUBSCRIBE 的底层实现，它将客户端和所订阅的模式添加到redisServer.pubsub_patterns 当中： 123456789101112131415161718192021222324252627// 订阅指定模式 // 订阅成功返回 1 ，如果已经订阅过，返回 0 int pubsubSubscribePattern(redisClient *c, robj *pattern) &#123; int retval = 0; // 向 c-&gt;pubsub_patterns 中查找指定 pattern // 如果返回值为 NULL ，说明这个 pattern 还没被这个客户端订阅过 if (listSearchKey(c-&gt;pubsub_patterns,pattern) == NULL) &#123; retval = 1; // 添加 pattern 到客户端 pubsub_patterns listAddNodeTail(c-&gt;pubsub_patterns,pattern); incrRefCount(pattern); // 将 pattern 添加到服务器 pubsubPattern *pat; pat = zmalloc(sizeof(*pat)); pat-&gt;pattern = getDecodedObject(pattern); pat-&gt;client = c; listAddNodeTail(server.pubsub_patterns,pat); &#125; /* Notify the client */ addReply(c,shared.mbulkhdr[3]); addReply(c,shared.psubscribebulk); // 返回被订阅的模式 addReplyBulk(c,pattern); // 返回客户端当前已订阅的频道和模式数量的总和 addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+listLength(c-&gt;pubsub_patterns)); return retval; &#125; 这个的话如果每次添加都要去匹配每一个channel然后加client的话就太累了，这个东西也失去了意义，本来就是为了模式匹配的，这样一个个加，有点繁琐了。为了能让这玩意儿起作用，在publish中会在这里也遍历一次，在publish相应的执行函数中进行channel的对比，匹配上了就发。 UNSUBSCRIBE 不订阅 这个就比较随意啦，就不细讲。 TIPS个人一些理解上卡的关键点： 1.在没有一个channel的情况下是通过怎样的方式创建channel的呢？ 这个要结合源代码来看，没有channel的时候，其实也就是这个channel被首次订阅的时候，这个时候会调用dictAdd，而且是加在服务端serer.pubsub上的，细节可以看上面的源码，。 2.如果自己没订阅的话别人订阅了，那在pubsub里面有其他人订阅了了岂不是自己就订阅不了了？ 这个是我自己眼角膜不要了，我没看清楚的是在订阅相关的函数中第一个if条件中的pubsub是c-&gt;pubsub_channels，也就是说是客户端的一个字典，客户端的字典只是存了自己订阅的，里面的值啥都没有的。而下面的de的判断是server.pubsub，也就是远程的，那里面的list就会保存所有订阅了相应channel的客户端了。 3.为什么有ht[0]，ht[1]，没有2和3或4吗？ 通过搜索资料发现，dicth哈希字典里面自带了两个哈希表，0和1，这个人家里面本来就有，没得杠。dictht0是直接存储哈希表的地方， dictht1在rehash中用到。里面的一些详细问题暂时还没有参透，日后再说。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"IOTA-介绍","slug":"IOTA-介绍","date":"2019-11-14T10:21:54.000Z","updated":"2019-11-16T08:36:50.076Z","comments":true,"path":"2019/11/14/IOTA-介绍/","link":"","permalink":"http://yoursite.com/2019/11/14/IOTA-%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"引言本文参考了https://www.jianshu.com/p/45c72f6cb417https://www.iotachina.com/what-is-iota 简介 IOTA是为物联网（IoT）而设计的一个革命性的新型交易结算和数据转移层。它基于新型的分布式账本——Tangle（缠结）。Tangle能够克服现有区块链设计中的低效性，并为去中心化P2P系统共识的达成创造了一种新方法。通过IOTA进行转账不需要支付手续费，这是首例。这也就意味着，无论是多小额的支付都能通过IOTA完成。 IOTA的Tangle和区块链有什么不同？最小单位 区块链的最小单位是区块（可能包含多个交易） IOTA的最小单位是一次交易 架构他们是两个完全独立的架构，但是却建立在同一种规则之上。 IOTA共识机制创新 区块链共识是通过一个非常严格的机制完成的，区块链中添加下一个区块需要多方进行竞争，并获取区块奖励或交易手续费。正因如此，共识和交易生成是分离开的，并且由网络的一小部分人来完成，通常会设置较高门槛（就像比特币一样），这样会导致进一步的中心化。 在IOTA系统中，网络中的每位参与者都能进行交易并且积极参与共识。更具体点说，你直接定位了两笔交易（主交易和分支交易），且间接在子tangle中定位其它交易。通过这种方式，验证就能同步进行，网络能够保持完全去中心化，不需要矿工传递信任，也不需要支付交易手续费。 https://www.jianshu.com/p/ced888ba7d3a确认和共识讲解 手续费 基于比特币的交易需要支付矿工手续费，这里的矿工就是建立区块的节点。在未来小微支付广泛存在的物联网场景中，这种交易方式并不适用，因为这个手续费会大概率超过微小交易本身的价值，这种情况是非常不合理的。 同时，由于矿工的存在，使得比特币系统不可避免地拥有了节点二元性的特点 节点二元性：一类节点是参与交易的，而一类节点是参与确认交易的。这种二元性将会造成资源分配问题和公平性问题。 解决 ： 在IOTA中，每一笔新交易发生之前，该笔交易的节点首先要选择之前两个旧交易进行验证。验证通过后，该交易和被验证的两笔交易绑定。也就是说，要在IOTA网络上发行交易，就要对之前的交易进行验证。参与交易的每个节点都要承担一些矿工的义务，对整个网络的交易真实性负责。 这种记账的方式，不需要矿工，也不需要大量节点验证，这就节省了手续费和算力资源。有效地消除了手续费和网络二元性的问题，更加适用于大量节点之间小额交易的物联网场景。 交易过程选择旧交易一个节点在发行一个新的交易之前，首先要选择已经发生过的两个交易进行验证。关于选择哪两个交易，是IOTA技术的关键，最简单的策略是随机选择，并且要在还未被验证过的交易中进行选择。 （关键技术，还要深入） 验证旧交易选择好旧交易后，节点会对它们进行验证。要检查交易的签名是否正确，生成该交易的工作量大小，以及是否和与之直接或间接相连的交易有冲突。如果有冲突，则重新选择旧交易；如果没有冲突，则验证通过。 绑定旧交易验证通过后，节点将新生成的交易与已被验证的交易进行绑定。绑定过程需要做一点PoW计算，类似于比特币中的矿工，需要找到一个随机数满足如下条件：该随机数和被验证交易中的某个数值连接成新的字符串，该字符串对应的哈希值应满足某个固定格式。 （待补充，然后呢，需要广播吗》） （待补充）每次交易干了啥数据结构 IOTA的和其他代币最根本的区别是底层数据结构的不同。其他代币大多是用区块链存储交易数据，而IOTA则是采用了缠结Tangle作为其底层的数据结构。 Tangle Tangle是一种存储交易数据的有向无环图（Directed Acyclic Graph, DAG），其基本结构如图1所示。 （待加图） 风险交易冲突 IOTA通过交易权重解决这个问题。 每个交易在生成时，都会附带两个权重值。 自有权重，为3的指数，固定不变； 累计权重，是其后续绑定交易自有权重的累加，随着交易的增多而变大。 （待补充）权重怎么算，权重怎么起作用 pow共识机制 交易在被验证的时候，两个权重值是重要参考指标。累计权重越大的交易，意味着其可信度越高。在交易冲突发生的时候，会比较两个交易的累计权重，并舍弃那个累计权重较小的交易及其分支，后续如果遇到合适的时机会会再加上。","categories":[{"name":"IOTA","slug":"IOTA","permalink":"http://yoursite.com/categories/IOTA/"}],"tags":[{"name":"IOTA","slug":"IOTA","permalink":"http://yoursite.com/tags/IOTA/"},{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"论文","slug":"论文","permalink":"http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Redis-常用命令","slug":"Redis-常用命令","date":"2019-11-14T10:21:54.000Z","updated":"2019-11-16T08:24:53.428Z","comments":true,"path":"2019/11/14/Redis-常用命令/","link":"","permalink":"http://yoursite.com/2019/11/14/Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"引言参考 https://blog.csdn.net/weixx3/article/details/92188775暂未附上声明 #","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"java-拆箱装箱","slug":"java-拆箱装箱","date":"2019-11-09T10:21:54.000Z","updated":"2019-11-17T12:55:42.247Z","comments":true,"path":"2019/11/09/java-拆箱装箱/","link":"","permalink":"http://yoursite.com/2019/11/09/java-%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1/","excerpt":"","text":"前言本文转载于http://www.cnblogs.com/dolphin0520/p/3780005.html并根据自己的理解方式做了表达上的修改 概念Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行： 1Integer i = new Integer(10); 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了： 1Integer i = 10; 这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。 而拆箱就是将包装器类型的转化为基本数据类型的一个过程 12Integer i = 10; //装箱int n = i; //拆箱 实现原理Integer为例： 66通过javap -c 对.java文件进行反编译得到.class文件得到如下结果 在装箱的时候自动调用的是Integer的valueOf(int)方法 在拆箱的时候自动调用的是Integer的intValue方法 其他的数据类型也都是按照相似的方式拆箱装箱的 源码解析","categories":[{"name":"JAVA基础","slug":"JAVA基础","permalink":"http://yoursite.com/categories/JAVA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"数据类型","slug":"数据类型","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"leetcode-最大回文子串","slug":"leetcode-最大回文子串","date":"2019-11-09T08:07:50.000Z","updated":"2019-11-09T08:58:45.629Z","comments":true,"path":"2019/11/09/leetcode-最大回文子串/","link":"","permalink":"http://yoursite.com/2019/11/09/leetcode-%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","excerpt":"","text":"暴力法不多做详解 1.中心扩展法此方法主要思想:通过查找以字符串中以某个字符为中心的回文子串是有多长，来得到每个回文子串的大小。对于这个子串，我们就从中心出发，向两边扩展，如果扩展后还是回文串，那么继续扩展，直到不是回文串，我们就可以将子串长度记录下来了。对于向两边扩展，我们可以通过一个下标来表示（也可以用指针），p1和p2。 现在有个问题，aabbaa和aabaa都是回文串，所以在打代码的时候就要稍稍做个处理。 两种情况 回文子串是奇数个，那么中心点就是一个字符，所以初始状态，p1和p2是指向同一个字符的。 回文子串是偶数个，那么中心就是两个字符，所以初始状态，p1和p2是指向两个相同字符的。 对于两种情况的处理打代码稍稍注意下就好了，问题不大。（这个方法暂无代码……） 2.动态规划主要思想：对于i到j是否是回文子串，我们只需要判断两个问题： i位置和j位置两个字符是否相同 如果相同了就判断i+1和j-1是否是个回文窜 有了这两点就没啥问题了 公式如下： 1dp[i][j] = dp[i+1][j-1] 这里的dp[i][j]存放的是boolean类型的，下面的dp存的是回文串长度 因为i一定会比j小，所以在二维数组上的操作要多多注意 一段比较原始的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String longestPalindrome(String s) &#123; if (s.length() &lt;=1)&#123; return s; &#125; int len = s.length(); int dp[][] = new int[len][len]; //初始化dp数组，主要是a和aa这种先准备好 //dp数组每个格子存放当前i到j的回文子串长度 for (int i = 0;i &lt; len;i++)&#123; dp[i][i] = 1; //i到i（单个字符）就是个回文串 if (i != len-1)&#123; //aa也是个回文串 if (s.charAt(i) == s.charAt(i+1))&#123; dp[i][i+1] = 2; &#125; &#125; &#125; //这个循环和是纵列在外，横行在内 for (int i = 2; i &lt; len; i ++)&#123; //这里是j到i for (int j = 0;j &lt; i-1;j++)&#123; if (s.charAt(j) == s.charAt(i))&#123; if (dp[j+1][i-1] == 0)&#123; dp[j][i] = dp[j+1][i-1]; &#125;else &#123; dp[j][i] = dp[j+1][i-1] +2 ; &#125; &#125; &#125; &#125; //把最大子串给截出来 int left = 0; int right = 0; int maxlen = 0; for (int i =0;i&lt; len;i++)&#123; for (int j = i;j &lt; len;j++)&#123; if (dp[i][j] &gt; maxlen)&#123; maxlen = dp[i][j]; left = i; right = j; &#125; &#125; &#125; return s.substring(left,right+1); &#125; 3.Manacher算法（待更）","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Linux下权限的修改设置","slug":"linux-permission","date":"2019-11-08T08:46:26.000Z","updated":"2019-11-09T07:03:19.907Z","comments":true,"path":"2019/11/08/linux-permission/","link":"","permalink":"http://yoursite.com/2019/11/08/linux-permission/","excerpt":"","text":"修改文件权限1$ chmod -R 777 files 1.先来讲讲数字777代表的是三个级别的身份owner/group/others 对于每个级别都有三个不同的权限 r 读权限read 4，100 w 写权限write 2，010 x 操作权限execute 1， 001 如果rwx都可以，就对三个数进行相加，等于7。这个就相当于3bit的位来表示单个级别身份的权限，某个位上的1表示有这个位代表的权限，0表示没有 2.接着讲讲 R对于R的话其实表示：对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) 3.其他当然除了 1chmod -R XXX file.txt 也有其他的方式，主要是依据owner/group/others三个用户来的。 栗子：设置文件拥有者权限为可写，组合为可读，其他用户删去可执行权限 1chmod u+w,g+r,o-x files.txt own对应 u group对应 g other对应 o 所有对应 a 此处自己只是列举了自己常用的，部分深入的细节没有完全解释清楚，网上也有大片的参考。 详细的可以百度chmod","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"初来乍到","slug":"myblog-creation","date":"2019-11-08T05:54:13.000Z","updated":"2019-11-17T05:35:04.491Z","comments":false,"path":"2019/11/08/myblog-creation/","link":"","permalink":"http://yoursite.com/2019/11/08/myblog-creation/","excerpt":"","text":"第一次建站，若有问题欢迎大家指正。 有问题欢迎大家发送邮件和我探讨交流172544714@qq.com","categories":[{"name":"Helloworld","slug":"Helloworld","permalink":"http://yoursite.com/categories/Helloworld/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://yoursite.com/tags/HEXO/"}]}]}