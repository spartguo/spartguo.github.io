<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>禹哥小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-16T13:37:47.590Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>spartguo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis-发布者订阅者</title>
    <link href="http://yoursite.com/2019/11/16/Redis-%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85/"/>
    <id>http://yoursite.com/2019/11/16/Redis-发布者订阅者/</id>
    <published>2019-11-16T10:21:54.000Z</published>
    <updated>2019-11-16T13:37:47.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文参考了<br><a href="https://blog.csdn.net/clh604/article/details/19754939" target="_blank" rel="noopener">https://blog.csdn.net/clh604/article/details/19754939</a><br><a href="https://blog.csdn.net/gududedabai/article/details/80326129" target="_blank" rel="noopener">https://blog.csdn.net/gududedabai/article/details/80326129</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>为了解耦发布者(publisher)和订阅者(subscriber)之间的关系，Redis 使用了 channel (频道)作为两者的中介 —— 发布者将信息直接发布给 channel ，而 channel 负责将信息发送给适当的订阅者，发布者和订阅者之间没有相互关系，也不知道对方的存在：</p></blockquote><h1 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h1><p>这里主要想写样例：</p><h2 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h2><blockquote><p>发布消息</p></blockquote><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h3 id="实现（源码）"><a href="#实现（源码）" class="headerlink" title="实现（源码）"></a>实现（源码）</h3><p>PUBLISH的命令主要有这两个步骤</p><ul><li><p>使用给定的频道作为键，在 redisServer.pubsub_channels 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p></li><li><p>遍历 redisServer.pubsub_patterns 链表，将链表中的模式和给定的频道进行匹配，如果匹配成功，那么将消息发布到相应模式的客户端当中。</p></li></ul><p>PUBLISH 命令的实际实现由 pubsubPublishMessage 函数完成，它的完整定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubPublishMessage</span><span class="params">(robj *channel, robj *message)</span> </span>&#123; </span><br><span class="line">　　<span class="keyword">int</span> receivers = <span class="number">0</span>; </span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">de</span>;</span> </span><br><span class="line">　　listNode *ln; </span><br><span class="line">　　listIter li; </span><br><span class="line">　　<span class="comment">/* Send to clients listening for that channel */</span> </span><br><span class="line">　　<span class="comment">// 向频道的所有订阅者发送消息 </span></span><br><span class="line">　　de = dictFind(server.pubsub_channels,channel); </span><br><span class="line">　　<span class="keyword">if</span> (de) &#123; </span><br><span class="line">    　　<span class="built_in">list</span> *<span class="built_in">list</span> = dictGetVal(de); <span class="comment">// 取出所有订阅者 </span></span><br><span class="line">    　　listNode *ln; </span><br><span class="line">    　　listIter li; </span><br><span class="line">    　　<span class="comment">// 遍历所有订阅者， 向它们发送消息 </span></span><br><span class="line">    　　listRewind(<span class="built_in">list</span>,&amp;li); </span><br><span class="line">    　　<span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        　　redisClient *c = ln-&gt;value; </span><br><span class="line">        　　addReply(c,shared.mbulkhdr[<span class="number">3</span>]); </span><br><span class="line">        　　addReply(c,shared.messagebulk); </span><br><span class="line">        　　addReplyBulk(c,channel); <span class="comment">// 打印频道名 </span></span><br><span class="line">        　　addReplyBulk(c,message); <span class="comment">// 打印消息 </span></span><br><span class="line">        　　receivers++; <span class="comment">// 更新接收者数量 </span></span><br><span class="line">    　　&#125; </span><br><span class="line">　　&#125; </span><br><span class="line">　　<span class="comment">/* Send to clients listening to matching channels */</span> </span><br><span class="line">　　<span class="comment">// 向所有被匹配模式的订阅者发送消息 </span></span><br><span class="line">　　<span class="keyword">if</span> (listLength(server.pubsub_patterns)) &#123; </span><br><span class="line">    　　listRewind(server.pubsub_patterns,&amp;li); <span class="comment">// 取出所有模式 </span></span><br><span class="line">    　　channel = getDecodedObject(channel); </span><br><span class="line">    　　<span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123; </span><br><span class="line">        　　pubsubPattern *pat = ln-&gt;value; <span class="comment">// 取出模式 </span></span><br><span class="line">        　　<span class="comment">// 如果模式和 channel 匹配的话 </span></span><br><span class="line">        　　<span class="comment">// 向这个channel的订阅者发送消息 </span></span><br><span class="line">        　　<span class="keyword">if</span> (stringmatchlen((<span class="keyword">char</span>*)pat-&gt;pattern-&gt;ptr, </span><br><span class="line">        　　sdslen(pat-&gt;pattern-&gt;ptr), </span><br><span class="line">        　　(<span class="keyword">char</span>*)channel-&gt;ptr, </span><br><span class="line">        　　sdslen(channel-&gt;ptr),<span class="number">0</span>)) &#123; </span><br><span class="line">            　　addReply(pat-&gt;client,shared.mbulkhdr[<span class="number">4</span>]); </span><br><span class="line">            　　addReply(pat-&gt;client,shared.pmessagebulk); </span><br><span class="line">            　　addReplyBulk(pat-&gt;client,pat-&gt;pattern); <span class="comment">// 打印被匹配的模式 </span></span><br><span class="line">            　　addReplyBulk(pat-&gt;client,channel); <span class="comment">// 打印频道名 </span></span><br><span class="line">            　　addReplyBulk(pat-&gt;client,message); <span class="comment">// 打印消息 </span></span><br><span class="line">            　　receivers++; <span class="comment">// 更新接收者数量 </span></span><br><span class="line">　　        &#125; </span><br><span class="line">　　    &#125; </span><br><span class="line">　　    decrRefCount(channel); <span class="comment">// 释放用过的 channel </span></span><br><span class="line">　　&#125; </span><br><span class="line">　　<span class="keyword">return</span> receivers; <span class="comment">// 返回接收者数量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h2><blockquote><p>订阅频道</p></blockquote><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h3><h3 id="实现（源码）-1"><a href="#实现（源码）-1" class="headerlink" title="实现（源码）"></a>实现（源码）</h3><p><strong>数据结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span> </span><br><span class="line">　　<span class="comment">// 省略 ... </span></span><br><span class="line">　　dict *pubsub_channels; </span><br><span class="line"><span class="comment">// Map channels to list of subscribed clients </span></span><br><span class="line">　　<span class="comment">// 省略 ... </span></span><br><span class="line">　　&#125;;</span><br></pre></td></tr></table></figure><p>pubsub_channels是个<strong>字典</strong>，字典的<strong>键</strong>就是一个个 <strong>channel</strong> ，而字典的<strong>值</strong>则是一个<strong>链表</strong>，链表中保存了所有订阅这个 channel 的客户端。(haspmap之类)，所以要订阅就现需要在里面加上自己</p><p>函数 pubsubSubscribeChannel 是 SUBSCRIBE 命令的底层实现，它完成了将客户端添加到订阅链表中的工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 订阅指定频道 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅成功返回 1 ，如果已经订阅过，返回 0 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribeChannel</span><span class="params">(redisClient *c, robj *channel)</span> </span>&#123; </span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">de</span>;</span> </span><br><span class="line">　　<span class="built_in">list</span> *clients = <span class="literal">NULL</span>; </span><br><span class="line">　　<span class="keyword">int</span> retval = <span class="number">0</span>; </span><br><span class="line">　　<span class="comment">/* Add the channel to the client -&gt; channels hash table */</span> </span><br><span class="line">　　<span class="comment">/*dictadd函数其实就是在字典里面加键值对，channel作为键，null为值</span></span><br><span class="line"><span class="comment">    这个函数会检查是否存在现有的channel，没有的话就创建一个，加到客户端的pubsub里面</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//---------------关键--------------------</span></span><br><span class="line">　　<span class="keyword">if</span> (dictAdd(c-&gt;pubsub_channels,channel,<span class="literal">NULL</span>) == DICT_OK) &#123; </span><br><span class="line">　　    retval = <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//函数的作用是增加对对象的引用，我不知道要干啥,不过我知道引用为0会被删掉</span></span><br><span class="line">　　    incrRefCount(channel); </span><br><span class="line">    　　<span class="comment">/* Add the client to the channel -&gt; list of clients hash table */</span> </span><br><span class="line">    　　<span class="comment">// 将 client 添加到订阅给定 channel 的链表中 </span></span><br><span class="line">    　　<span class="comment">// 这个链表是一个哈希表的值，哈希表的键是给定 channel </span></span><br><span class="line">    　　<span class="comment">// 这个哈希表保存在 server.pubsub_channels 里 </span></span><br><span class="line">        <span class="comment">//-----------------关键-------------------</span></span><br><span class="line">    　　de = dictFind(server.pubsub_channels,channel);</span><br><span class="line">    　　<span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        　　<span class="comment">// 如果 de 等于 NULL </span></span><br><span class="line">        　　<span class="comment">// 表示这个客户端是首个订阅这个 channel 的客户端 </span></span><br><span class="line">        　　<span class="comment">// 那么创建一个新的列表， 并将它加入到哈希表中 </span></span><br><span class="line">        　　clients = listCreate(); </span><br><span class="line">        　　dictAdd(server.pubsub_channels,channel,clients); </span><br><span class="line">        　　incrRefCount(channel); </span><br><span class="line">    　　&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        　　<span class="comment">// 如果 de 不为空，就取出这个 clients 链表 </span></span><br><span class="line">        　　clients = dictGetVal(de); </span><br><span class="line">　　    &#125; </span><br><span class="line">    　　<span class="comment">// 将客户端加入到链表中 </span></span><br><span class="line">    　　listAddNodeTail(clients,c); </span><br><span class="line">　　&#125; </span><br><span class="line">　　<span class="comment">/* Notify the client */</span> </span><br><span class="line">　　addReply(c,shared.mbulkhdr[<span class="number">3</span>]); </span><br><span class="line">　　addReply(c,shared.subscribebulk); </span><br><span class="line">　　<span class="comment">// 返回订阅的频道 </span></span><br><span class="line">　　addReplyBulk(c,channel); </span><br><span class="line">　　<span class="comment">// 返回客户端当前已订阅的频道和模式数量的总和 </span></span><br><span class="line">　　addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+listLength(c-&gt;pubsub_patterns)); </span><br><span class="line">　　<span class="keyword">return</span> retval; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>dictAdd(...)</code>源码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将给定键值对添加到字典中</span></span><br><span class="line"><span class="comment"> * 只有给定键 key 不存在于字典时，添加操作才会成功</span></span><br><span class="line"><span class="comment"> * 添加成功返回 DICT_OK , 失败返回 DICT_ERR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 新建节点,entry=null */</span></span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);  </span><br><span class="line">    <span class="comment">/* 如果entry不为null，返回1 */</span></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">/* 给节点赋值 */</span></span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="comment">/*先添加键再添加值*/</span></span><br><span class="line">    <span class="comment">/* 操作成功，返回0 */</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht; <span class="comment">/* 指向字典中的hash表 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 判断字典此时是否正在rehash */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 如果新元素（key）已经存在，那么index=-1，否则index就是新元素的下标值 */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 给新的entry分配内存空间并且保存新的entry，</span></span><br><span class="line"><span class="comment">     * 在这里，会将新的元素放在hash表的表头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 如果字典这是正在rehash，那么会将entry添加到ht[1]中去；否则添加到ht[0] */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;<span class="comment">/* 更新hash表中used属性的值 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置entry的key */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h2><blockquote><p>订阅模式（多个频道）</p></blockquote><h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><h3 id="实现（源码）-2"><a href="#实现（源码）-2" class="headerlink" title="实现（源码）"></a>实现（源码）</h3><p><strong>数据结构</strong></p><p>和 redisServer.pubsub_channels 属性类似， redisServer.pubsub_patterns 属性用于保存所有被订阅的模式，和 pubsub_channels 不同的是， pubsub_patterns 是一个链表(而不是字典)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span> </span><br><span class="line">　　<span class="comment">// ...... </span></span><br><span class="line">　　<span class="built_in">list</span> *pubsub_patterns; </span><br><span class="line">    <span class="comment">// A list of pubsub_patterns </span></span><br><span class="line">　　<span class="comment">// ...... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pubsubSubscribePattern 是 PSUBSCRIBE 的底层实现，它将客户端和所订阅的模式添加到redisServer.pubsub_patterns 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅指定模式 </span></span><br><span class="line"><span class="comment">// 订阅成功返回 1 ，如果已经订阅过，返回 0 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pubsubSubscribePattern</span><span class="params">(redisClient *c, robj *pattern)</span> </span>&#123; </span><br><span class="line">　　<span class="keyword">int</span> retval = <span class="number">0</span>; </span><br><span class="line">　　<span class="comment">// 向 c-&gt;pubsub_patterns 中查找指定 pattern </span></span><br><span class="line">　　<span class="comment">// 如果返回值为 NULL ，说明这个 pattern 还没被这个客户端订阅过 </span></span><br><span class="line">　　<span class="keyword">if</span> (listSearchKey(c-&gt;pubsub_patterns,pattern) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">    　　retval = <span class="number">1</span>; </span><br><span class="line">    　　<span class="comment">// 添加 pattern 到客户端 pubsub_patterns </span></span><br><span class="line">    　　listAddNodeTail(c-&gt;pubsub_patterns,pattern); </span><br><span class="line">    　　incrRefCount(pattern); </span><br><span class="line">    　　<span class="comment">// 将 pattern 添加到服务器 </span></span><br><span class="line">    　　pubsubPattern *pat; </span><br><span class="line">    　　pat = zmalloc(<span class="keyword">sizeof</span>(*pat)); </span><br><span class="line">    　　pat-&gt;pattern = getDecodedObject(pattern); </span><br><span class="line">    　　pat-&gt;client = c; </span><br><span class="line">    　　listAddNodeTail(server.pubsub_patterns,pat); </span><br><span class="line">　　&#125; </span><br><span class="line">　　<span class="comment">/* Notify the client */</span> </span><br><span class="line">　　addReply(c,shared.mbulkhdr[<span class="number">3</span>]); </span><br><span class="line">　　addReply(c,shared.psubscribebulk); </span><br><span class="line">　　<span class="comment">// 返回被订阅的模式 </span></span><br><span class="line">　　addReplyBulk(c,pattern); </span><br><span class="line">　　<span class="comment">// 返回客户端当前已订阅的频道和模式数量的总和 </span></span><br><span class="line">　　addReplyLongLong(c,dictSize(c-&gt;pubsub_channels)+listLength(c-&gt;pubsub_patterns)); </span><br><span class="line">　　<span class="keyword">return</span> retval; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个的话如果每次添加都要去匹配每一个channel然后加client的话就太累了，这个东西也失去了意义，本来就是为了模式匹配的，这样一个个加，有点繁琐了。为了能让这玩意儿起作用，在publish中会在这里也遍历一次，在publish相应的执行函数中进行channel的对比，匹配上了就发。</p><h2 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h2><blockquote><p>不订阅</p></blockquote><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>而对于</p><h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><p>个人一些理解上卡的关键点：  </p><p><strong>1.在没有一个channel的情况下是通过怎样的方式创建channel的呢？</strong>  </p><blockquote><p>这个要结合源代码来看，没有channel的时候，其实也就是这个channel被首次订阅的时候，这个时候会调用dictAdd，而且是加在服务端serer.pubsub上的，细节可以看上面的源码，。</p></blockquote><p><strong>2.如果自己没订阅的话别人订阅了，那在pubsub里面有其他人订阅了了岂不是自己就订阅不了了？</strong></p><blockquote><p>这个是我自己眼角膜不要了，我没看清楚的是在订阅相关的函数中第一个if条件中的pubsub是c-&gt;pubsub_channels，也就是说是客户端的一个字典，客户端的字典只是存了自己订阅的，里面的值啥都没有的。而下面的de的判断是server.pubsub，也就是远程的，那里面的list就会保存所有订阅了相应channel的客户端了。</p></blockquote><p><strong>3.为什么有ht[0]，ht[1]，没有2和3或4吗？</strong></p><blockquote><p>通过搜索资料发现，dicth哈希字典里面自带了两个哈希表，0和1，这个人家里面本来就有，没得杠。dictht0是直接存储哈希表的地方， dictht1在rehash中用到。<br>里面的一些详细问题暂时还没有参透，日后再说。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;本文参考了&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/clh604/article/details/1975493
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>IOTA-介绍</title>
    <link href="http://yoursite.com/2019/11/14/IOTA-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/11/14/IOTA-介绍/</id>
    <published>2019-11-14T10:21:54.000Z</published>
    <updated>2019-11-16T08:36:50.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本文参考了<br><a href="https://www.jianshu.com/p/45c72f6cb417" target="_blank" rel="noopener">https://www.jianshu.com/p/45c72f6cb417</a><br><a href="https://www.iotachina.com/what-is-iota" target="_blank" rel="noopener">https://www.iotachina.com/what-is-iota</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>IOTA是为物联网（IoT）而设计的一个革命性的新型交易结算和数据转移层。它基于新型的分布式账本——Tangle（缠结）。Tangle能够克服现有区块链设计中的低效性，并为去中心化P2P系统共识的达成创造了一种新方法。通过IOTA进行转账不需要支付手续费，这是首例。这也就意味着，无论是多小额的支付都能通过IOTA完成。  </p></blockquote><h2 id="IOTA的Tangle和区块链有什么不同？"><a href="#IOTA的Tangle和区块链有什么不同？" class="headerlink" title="IOTA的Tangle和区块链有什么不同？"></a>IOTA的Tangle和区块链有什么不同？</h2><h3 id="最小单位"><a href="#最小单位" class="headerlink" title="最小单位"></a>最小单位</h3><ul><li>区块链的最小单位是<strong>区块</strong>（可能包含多个交易）</li><li>IOTA的最小单位是<strong>一次交易</strong></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>他们是两个完全独立的架构，但是却建立在同一种规则之上。</p><h3 id="IOTA共识机制创新"><a href="#IOTA共识机制创新" class="headerlink" title="IOTA共识机制创新"></a>IOTA共识机制创新</h3><ul><li><p>区块链共识是通过一个非常严格的机制完成的，区块链中添加下一个区块需要多方进行竞争，并获取区块奖励或交易手续费。正因如此，共识和交易生成是分离开的，并且由网络的一小部分人来完成，通常会设置较高门槛（就像比特币一样），这样会导致进一步的中心化。</p></li><li><p>在IOTA系统中，网络中的每位参与者都能进行交易并且积极参与共识。更具体点说，你直接定位了两笔交易（主交易和分支交易），且间接在子tangle中定位其它交易。通过这种方式，验证就能同步进行，网络能够保持完全去中心化，不需要矿工传递信任，也不需要支付交易手续费。</p></li></ul><p><a href="https://www.jianshu.com/p/ced888ba7d3a" target="_blank" rel="noopener">https://www.jianshu.com/p/ced888ba7d3a</a><br>确认和共识讲解</p><h3 id="手续费"><a href="#手续费" class="headerlink" title="手续费"></a>手续费</h3><ul><li><p>基于比特币的交易需要支付矿工手续费，这里的矿工就是建立区块的节点。在未来小微支付广泛存在的物联网场景中，这种交易方式并不适用，因为这个手续费会大概率超过微小交易本身的价值，这种情况是非常不合理的。</p></li><li><p>同时，由于矿工的存在，使得比特币系统不可避免地拥有了<strong>节点二元性</strong>的特点</p></li></ul><blockquote><p>节点二元性：一类节点是参与交易的，而一类节点是参与确认交易的。这种二元性将会造成资源分配问题和公平性问题。</p></blockquote><p><strong>解决</strong>  ：</p><blockquote><p>在IOTA中，每一笔新交易发生之前，该笔交易的节点首先要选择之前两个旧交易进行验证。验证通过后，该交易和被验证的两笔交易绑定。也就是说，要在IOTA网络上发行交易，就要对之前的交易进行验证。<strong>参与交易的每个节点都要承担一些矿工的义务</strong>，对整个网络的交易真实性负责。</p></blockquote><p>这种记账的方式，不需要矿工，也不需要大量节点验证，这就节省了手续费和算力资源。有效地消除了手续费和网络二元性的问题，更加适用于大量节点之间小额交易的物联网场景。</p><h1 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h1><h2 id="选择旧交易"><a href="#选择旧交易" class="headerlink" title="选择旧交易"></a>选择旧交易</h2><p>一个节点在发行一个新的交易之前，首先要选择已经发生过的两个交易进行验证。关于选择哪两个交易，是IOTA技术的关键，最简单的策略是随机选择，并且要在还未被验证过的交易中进行选择。</p><p>（关键技术，还要深入）</p><h2 id="验证旧交易"><a href="#验证旧交易" class="headerlink" title="验证旧交易"></a>验证旧交易</h2><p>选择好旧交易后，节点会对它们进行验证。要检查交易的签名是否正确，生成该交易的工作量大小，以及是否和与之直接或间接相连的交易有冲突。如果有冲突，则重新选择旧交易；如果没有冲突，则验证通过。</p><h2 id="绑定旧交易"><a href="#绑定旧交易" class="headerlink" title="绑定旧交易"></a>绑定旧交易</h2><p>验证通过后，节点将新生成的交易与已被验证的交易进行绑定。绑定过程需要做一点PoW计算，类似于比特币中的矿工，需要找到一个随机数满足如下条件：该随机数和被验证交易中的某个数值连接成新的字符串，该字符串对应的哈希值应满足某个固定格式。</p><p>（待补充，然后呢，需要广播吗》）</p><h2 id="（待补充）每次交易干了啥"><a href="#（待补充）每次交易干了啥" class="headerlink" title="（待补充）每次交易干了啥"></a>（待补充）每次交易干了啥</h2><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote><p>IOTA的和其他代币最根本的区别是底层数据结构的不同。其他代币大多是用区块链存储交易数据，而IOTA则是采用了<strong>缠结Tangle</strong>作为其底层的数据结构。</p></blockquote><h2 id="Tangle"><a href="#Tangle" class="headerlink" title="Tangle"></a>Tangle</h2><blockquote><p>Tangle是一种存储交易数据的<strong>有向无环图（Directed Acyclic Graph, DAG）</strong>，其基本结构如图1所示。</p></blockquote><p>（待加图）</p><h1 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h1><h2 id="交易冲突"><a href="#交易冲突" class="headerlink" title="交易冲突"></a>交易冲突</h2><blockquote><p>IOTA通过交易权重解决这个问题。</p></blockquote><p>每个交易在生成时，都会附带两个权重值。</p><ul><li>自有权重，为3的指数，固定不变；</li><li>累计权重，是其后续绑定交易自有权重的累加，随着交易的增多而变大。</li></ul><p>（待补充）权重怎么算，权重怎么起作用</p><p><a href="https://www.cnblogs.com/s-lisheng/p/11287328.html" target="_blank" rel="noopener">pow共识机制</a></p><p>交易在被验证的时候，两个权重值是重要参考指标。累计权重越大的交易，意味着其可信度越高。在交易冲突发生的时候，会比较两个交易的累计权重，并舍弃那个累计权重较小的交易及其分支，后续如果遇到合适的时机会会再加上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;本文参考了&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/45c72f6cb417&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="IOTA" scheme="http://yoursite.com/categories/IOTA/"/>
    
    
      <category term="IOTA" scheme="http://yoursite.com/tags/IOTA/"/>
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis-常用命令</title>
    <link href="http://yoursite.com/2019/11/14/Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/11/14/Redis-常用命令/</id>
    <published>2019-11-14T10:21:54.000Z</published>
    <updated>2019-11-16T08:24:53.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>参考  </p><p><a href="https://blog.csdn.net/weixx3/article/details/92188775" target="_blank" rel="noopener">https://blog.csdn.net/weixx3/article/details/92188775</a><br>暂未附上声明</p><p>#</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;参考  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixx3/article/details/9218
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="命令" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>java-拆箱装箱</title>
    <link href="http://yoursite.com/2019/11/09/java-%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1/"/>
    <id>http://yoursite.com/2019/11/09/java-拆箱装箱/</id>
    <published>2019-11-09T10:21:54.000Z</published>
    <updated>2019-11-09T10:49:42.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文转载于<br><a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3780005.html</a><br>并根据自己的理解方式做了表达上的修改</p><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。  </p><p>而拆箱就是将包装器类型的转化为基本数据类型的一个过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p><strong>Integer</strong>为例：  66<br>通过javap -c 对.java文件进行反编译得到.class文件<br>得到如下结果    </p><ul><li>在<strong>装箱</strong>的时候自动调用的是Integer的valueOf(int)方法</li><li>在<strong>拆箱</strong>的时候自动调用的是Integer的intValue方法</li></ul><p>其他的数据类型也都是按照相似的方式拆箱装箱的</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文转载于&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3780005.html&quot; t
      
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-最大回文子串</title>
    <link href="http://yoursite.com/2019/11/09/leetcode-%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/11/09/leetcode-最大回文子串/</id>
    <published>2019-11-09T08:07:50.000Z</published>
    <updated>2019-11-09T08:58:45.629Z</updated>
    
    <content type="html"><![CDATA[<p>暴力法不多做详解</p><h1 id="1-中心扩展法"><a href="#1-中心扩展法" class="headerlink" title="1.中心扩展法"></a>1.中心扩展法</h1><p>此方法<strong>主要思想</strong>:<br>通过查找以字符串中以某个字符为中心的回文子串是有多长，来得到每个回文子串的大小。对于这个子串，我们就从中心出发，向两边扩展，如果扩展后还是回文串，那么继续扩展，直到不是回文串，我们就可以将子串长度记录下来了。对于向两边扩展，我们可以通过一个下标来表示（也可以用指针），p1和p2。</p><p>现在有个问题，aabbaa和aabaa都是回文串，所以在打代码的时候就要稍稍做个处理。  </p><p>两种情况  </p><ul><li>回文子串是奇数个，那么中心点就是一个字符，所以初始状态，p1和p2是指向同一个字符的。</li><li>回文子串是偶数个，那么中心就是两个字符，所以初始状态，p1和p2是指向两个相同字符的。</li></ul><p>对于两种情况的处理打代码稍稍注意下就好了，问题不大。<br>（这个方法暂无代码……）</p><h1 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h1><p>主要思想：<br>对于i到j是否是回文子串，我们只需要判断两个问题：</p><ul><li>i位置和j位置两个字符是否相同</li><li>如果相同了就判断i+1和j-1是否是个回文窜</li></ul><p>有了这两点就没啥问题了</p><p>公式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i+1][j-1]</span><br></pre></td></tr></table></figure><p>这里的dp[i][j]存放的是boolean类型的，下面的dp存的是回文串长度</p><p>因为i一定会比j小，所以在二维数组上的操作要多多注意</p><p>一段比较原始的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="comment">//初始化dp数组，主要是a和aa这种先准备好</span></span><br><span class="line">        <span class="comment">//dp数组每个格子存放当前i到j的回文子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>; <span class="comment">//i到i（单个字符）就是个回文串</span></span><br><span class="line">            <span class="keyword">if</span> (i != len-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//aa也是个回文串</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][i+<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个循环和是纵列在外，横行在内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="comment">//这里是j到i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(j) == s.charAt(i))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j+<span class="number">1</span>][i-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[j][i] = dp[j+<span class="number">1</span>][i-<span class="number">1</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[j][i] = dp[j+<span class="number">1</span>][i-<span class="number">1</span>] +<span class="number">2</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把最大子串给截出来</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt;  maxlen)&#123;</span><br><span class="line">                    maxlen = dp[i][j];</span><br><span class="line">                    left = i;</span><br><span class="line">                    right = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-Manacher算法"><a href="#3-Manacher算法" class="headerlink" title="3.Manacher算法"></a>3.Manacher算法</h1><p>（待更）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;暴力法不多做详解&lt;/p&gt;
&lt;h1 id=&quot;1-中心扩展法&quot;&gt;&lt;a href=&quot;#1-中心扩展法&quot; class=&quot;headerlink&quot; title=&quot;1.中心扩展法&quot;&gt;&lt;/a&gt;1.中心扩展法&lt;/h1&gt;&lt;p&gt;此方法&lt;strong&gt;主要思想&lt;/strong&gt;:&lt;br&gt;通过查找以
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Linux下权限的修改设置</title>
    <link href="http://yoursite.com/2019/11/08/linux-permission/"/>
    <id>http://yoursite.com/2019/11/08/linux-permission/</id>
    <published>2019-11-08T08:46:26.000Z</published>
    <updated>2019-11-09T07:03:19.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a><strong>修改文件权限</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod -R 777 files</span><br></pre></td></tr></table></figure><h3 id="1-先来讲讲数字"><a href="#1-先来讲讲数字" class="headerlink" title="1.先来讲讲数字"></a><strong>1.先来讲讲数字</strong></h3><p>777代表的是三个级别的身份<br>owner/group/others</p><p>对于每个级别都有三个不同的权限</p><ul><li>r 读权限read  4，100</li><li>w 写权限write 2，010</li><li>x 操作权限execute 1，  001</li></ul><p>如果rwx都可以，就对三个数进行相加，等于7。这个就相当于3bit的位来表示单个级别身份的权限，某个位上的1表示有这个位代表的权限，0表示没有</p><h3 id="2-接着讲讲-R"><a href="#2-接着讲讲-R" class="headerlink" title="2.接着讲讲 R"></a><strong>2.接着讲讲 R</strong></h3><p>对于R的话其实表示：<br><strong>对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</strong></p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a><strong>3.其他</strong></h3><p>当然除了 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R XXX file.txt</span><br></pre></td></tr></table></figure><p>也有其他的方式，主要是依据owner/group/others三个用户来的。  </p><p>栗子：设置文件拥有者权限为可写，组合为可读，其他用户删去可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+w,g+r,o-x files.txt</span><br></pre></td></tr></table></figure><ul><li>own对应 u</li><li>group对应 g</li><li>other对应 o</li><li>所有对应 a</li></ul><hr><p>此处自己只是列举了自己常用的，部分深入的细节没有完全解释清楚，网上也有大片的参考。</p><p>详细的可以百度chmod</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;修改文件权限&quot;&gt;&lt;a href=&quot;#修改文件权限&quot; class=&quot;headerlink&quot; title=&quot;修改文件权限&quot;&gt;&lt;/a&gt;&lt;strong&gt;修改文件权限&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="命令" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>初来乍到</title>
    <link href="http://yoursite.com/2019/11/08/myblog-creation/"/>
    <id>http://yoursite.com/2019/11/08/myblog-creation/</id>
    <published>2019-11-08T05:54:13.000Z</published>
    <updated>2019-11-09T09:02:50.526Z</updated>
    
    <content type="html"><![CDATA[<p>第一次建站，若有问题欢迎大家指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次建站，若有问题欢迎大家指正。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Helloworld" scheme="http://yoursite.com/categories/Helloworld/"/>
    
    
      <category term="HEXO" scheme="http://yoursite.com/tags/HEXO/"/>
    
  </entry>
  
</feed>
